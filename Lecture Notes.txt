Process and Stack Frames
    Procedure call creates a new stack frame 
        Local variables
        Save registers (PC, etc.)
    CPU has stack support
        Hardware solutions for push/pop

Address Space - Stack 
    Size depends on the program
        Stack grows as program calls more procedure calls 
        Can be recycled once call returns
    OS manages process's stack 
        Can be fixed sized or dynamically extended
        Read/write and process private


Process State
    Registers (general, PC, processor status, stack/frame pointer)
    OS resources
        Open files, cwd, locks
    Requires a data structure to hold this information
    Some are not stored in process descriptor 
        Execution state is on stack
        Can be stored in supervisor-mode stack

Process Descriptor  
    Stores state, references to resources, information about support processes
    Used for scheduling, security, allocation
    Inserted into the process table (unique key-value pairs)

Handling Processes 
    Creating, Destroying, Running

Creating new process
    OS using a method to initialize
        No initial state or resources (windows approach)
    Requested by another process
        Clone the calling process (unix approach)
        Notion of parent/child relationship
        
Fork
    Creates two processes with diff IDs but mostly same
    Parent goes 'one way' and child goes 'the other'
    Child process 
        Own empty stack space
        Shared code reference
        Data starts out the same but may not stay the same...
    Copy on write
        Creating an entire new copy for the child is expensive
        Only when a process writes to data, the copy is made
        Lazy way of creating data segments
        Done at fine granularity (by pages, not by copying the entire data segment)

Exec 
    For making an entirely new process
    Used in conjunction with Fork call (can't be run by itself)
    Changes the code section of a process and resets state

Destroying a process
    Can be killed by the OS 
    Needs to reclaim memory, locks, and other resources
    Inform other processes that this process is over
    Remove from process table

Running a process 
    Ran by CPU (hardware)
    # processes >> # cores
    Scheduler regulates when and where processes are run
    Limited Direct Execution   
        Without OS intervention...  
        Unless the program makes a system call (hits a trap) and transfers control to the OS
        To optimize performance, enter the OS as seldom as possible

Loading a processes 
    Initialize hardware to clean state (process must get CPU in like-new condition)
    Load registers
    Init stack and stack pointer
    Set up memory structures
    Set PC 

Exceptions
    Sync exceptions 
        Can be handled by the code or the OS (may ekill program)
    Async exceptions (seg fault, abort, power failure)
        Unpredictable so the code can't check for them
        Try/catch blocks
        Sometimes they are used for system calls
        Hardware and OS catch exceptions and give control to OS

Using Traps for system calls   
    Priviledged instructions for system calls
    Prepare args for the sys call
    Linker will replace the original system call instruction with a trap
    Send the particular system call code to the OS
    Return back to instruction after the sys call

System Call Trap Gates
    Trap goes to trap vector table, where PS/PC are pushed onto the stack 
    Trap handler then redirects to the system call dispatch table 
    Dispatch table then goes to the 2nd level handler where the system call is impelemented
    When 2nd level handler returns, program returns to user mode, registers are restored

Stacking and Unstacking System calls
    Two stacks: one for user mode, one for kernel mode
    System calls use the kernel mode stack (contain return address to user mode, etc)

Blocked Process 
    OS maintains which processes are Blocked
    Could be waiting for I/O
    Once resource is available, scheduler/resource manager can mark the process as unblocked
    Blocking is needed for the schedule to know to wait    

Process Queue
    Data structure created by scheduler to determine the order to run processes 
    All processes in queue are in 'ready' state 

Scheduling Goals (relative priority varies depending on use case)
    Throughput - as much work as possible (for servers)
    Average wait time - interactiveness (for smartphones)
    Fairness - minimize worst case time (for multi-users)
    Priority goals - certain processes are more important (for different groups)
    Real time - items have deadlines to be met (niche case ie missile defense)

Scheduling: Policy and Mechanism
    Policy is the ideas of how the OS should act 
    Mechanism is how the OS accomplishes the desired policy 
    Separation of policy and mechanism makes it easier to change just one

Why don't we get ideal Throughput   
    Overhead to switch (ie save registers, switch)
    Scheduler takes time to dispatch (super linear??)

Response time exploding
    Systems have finite limits (queue size)
    Graceful degradation
        When system overloads, should continue to work but slightly worse
    
Real time schedule
    Certain taks need to happen at particular times
    Hard real time schedulers
        System fails if the deadline is not met
        Requires very careful analysis, cannot be dynamic
    Soft deadlines  
        Okay missing deadline, but goal is to meet 
        Different classes of deadlines (some more important than others)
        Can be dynamic 
    If deadlines are missed...
        Drop the job
        System may fall behind
    
Preemptive scheduling
    Requires a clock if programs don't relinquish control 
    Clock generates an interrupt at a fixed time interval 


Costs of Context switch 
    Entering the OS - Interrupt, save register, call scheduler
    Time for scheduler to decide which work to run 
    Switch stack and address spaces to new process
    Lose instruction and data caches

Multi-Level Feedback Queue
    Create multiple ready queues
        Short time tasks finish quickly (small time slices) -> improve interaction
        Long time tasks take longer (large time slices) -> becomes more like non-preemptive system, more efficient
    Deciding which processes go in which queues
        Start all processes in short time queue
        Move to longer queue if too many time slice ends
        Move to back to short time queue if end before time slice
    Real time queue doesn't use preemptive scheduling
    Dynamic and automatic adjustment based on job behavior

Priority scheduling Linux
    "nice" value
    Cannot raise priority by normal user, need to be sudo


