NAME: Prithvi Kannan
EMAIL: prithvi.kannan@gmail.com
ID: 405110096

Project 2A
Races and Synchronization

This project is about understanding synchronization issues and how to solve them. The first part of this assignment 
deals with conflicting read-modify-write operations on single variables and the second part is about complex data 
structures (an ordered linked list). 

I cited the following references provided in the spec:
    https://computing.llnl.gov/tutorials/pthreads/
    http://web.cs.ucla.edu/~harryxu/courses/111/winter20/ProjectGuide/lab2_add.gp
    http://web.cs.ucla.edu/~harryxu/courses/111/winter20/ProjectGuide/lab2_list.gp
    http://web.cs.ucla.edu/~harryxu/courses/111/winter20/ProjectGuide/SortedList.h

Files Included:
    lab2_add.c - a C program that implements and tests a shared variable add function, and produces output statistics
    SortedList.h - a header file (given by instructor) describing the interfaces for linked list operations
    SortedList.c - a C module that implements insert, delete, lookup, and length methods for a sorted doubly linked list with yield calls
    lab2_list.c - a C program that implements and produces the specified output statistics
    lab2_add.csv - containing all results for all of the Part-1 tests
    lab2_list.csv - containing all results for all of the Part-2 tests
    lab2_add-1.png - threads and iterations required to generate a failure (with and without yields)
    lab2_add-2.png - average time per operation with and without yields.
    lab2_add-3.png - average time per (single threaded) operation vs. the number of iterations.
    lab2_add-4.png - threads and iterations that can run successfully with yields under each of the synchronization options.
    lab2_add-5.png - average time per (protected) operation vs. the number of threads.
    lab2_list-1.png - average time per (single threaded) unprotected operation vs. number of iterations (illustrating the correction of the per-operation cost for the list length).
    lab2_list-2.png - threads and iterations required to generate a failure (with and without yields).
    lab2_list-3.png - iterations that can run (protected) without failure.
    lab2_list-4.png - (length-adjusted) cost per operation vs the number of threads for the various synchronization options.
    Makefile - containing targets to build, run 200+ specified test cases, make graphs, create tar and cleanup
    README - description of project
    lab2_add.gp - makes 5 plots for part-1 tests using GNUplot
    lab2_list.gp - makes 4 plots for part-2 tests using GNUplot
    
Why does it take iterations before errors are seen?
    example, 12 threads, 2 iteratiosn each will still give the right answers
    if it takes more time for a thread to be created then it takes for a thread to run, then the threads never bump into one another   
    if thread 1 is done before thread 2 is started, no problem
    when iterations go up, thread 1 doesnt finish before thread 2 is created, which creates the issues
    less iterations -> less chances to go wrong, less threads competing for resources

Cost of yielding
    why are --yield runs so much slower
        needs to switch threads 
    where is the time going
        context switch (better for threads than process)
    is it possible to get valid per-op timings if we are using --yield
        time of op + time of context switch go together

    